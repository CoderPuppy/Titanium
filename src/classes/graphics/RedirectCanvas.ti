--[[
    The RedirectCanvas is a class to be used by nodes that wish to redirect the term object. This canvas provides a terminal redirect and keeps track
    of the terminals properties set inside the wrapped program (via the term methods).

    This allows emulation of a shell program inside of Titanium without causing visual issues due to the shell program drawing directly to the canvas.
--]]
local stringLen, stringSub = string.len, string.sub
local isColour = term.isColour()

local function testColour( col )
    if not isColour then
        if col ~= 1 or col ~= 32768 or col ~= 256 or col ~= 128 then
            return error "Colour not supported"
        end
    end

    return true
end

class RedirectCanvas extends NodeCanvas {
    tX = 0;
    tY = 0;
    tColour = 1;
    tBackgroundColour = 32768;
    tCursor = false;
}

--[[
    @instance
    @desc Returns a table compatible with `term.redirect`
    @return <table - redirect>
]]
function RedirectCanvas:getTerminalRedirect()
    local redirect = {}

    function redirect.write( text )
        text = tostring( text )
        local tc, bg, tX, tY = self.tColour, self.tBackgroundColour, self.tX, self.tY
        local buffer, position = self.buffer, self.width * ( tY - 1 ) + tX

        for i = 1, math.min( stringLen( text ), self.width - tX + 1 ) do
            buffer[ position ] = { stringSub( text, i, i ), tc, bg }
            position = position + 1
        end

        self.tX = tX + stringLen( text )
    end

    function redirect.blit( text, colour, background )
        if stringLen( text ) ~= stringLen( colour ) or stringLen( text ) ~= stringLen( background ) then
            return error "blit arguments must be the same length"
        end

        local tX, hex = self.tX, TermCanvas.static.hex
        local buffer, position = self.buffer, self.width * ( self.tY - 1 ) + tX

        for i = 1, math.min( stringLen( text ), self.width - tX + 1 ) do
            buffer[ position ] = { stringSub( text, i, i ), hex[ stringSub( colour, i, i ) ], hex[ stringSub( background, i, i ) ] }
            position = position + 1
        end

        self.tX = tX + stringLen( text )
    end

    function redirect.clear()
        self:clear()
    end

    function redirect.clearLine()
        local px = { " ", self.tColour, self.tBackgroundColour }
        local buffer, position = self.buffer, self.width * ( self.tY - 1 )

        for i = 1, self.width do
            buffer[ position ] = px
            position = position + 1
        end
    end

    function redirect.getCursorPos()
        return self.tX, self.tY
    end

    function redirect.setCursorPos( x, y )
        self.tX, self.tY = math.floor( x ), math.floor( y )
    end

    function redirect.getSize()
        return self.width, self.height
    end

    function redirect.setCursorBlink( blink )
        self.tCursor = blink
    end

    function redirect.setTextColour( tc )
        if testColour( tc ) then
            self.tColour = tc
        end
    end

    function redirect.getTextColour()
        return self.tColour
    end

    function redirect.setBackgroundColour( bg )
        if testColour( bg ) then
            self.tColour = tc
        end
    end

    function redirect.getBackgroundColour()
        return self.tBackgroundColour
    end

    function redirect.scroll( n )
        local offset, buffer, nL = self.width * n, self.buffer, n < 0
        local pixelCount, blank = self.width * self.height, { " ", self.tColour, self.tBackgroundColour }

        for i = nL and pixelCount or 1, nL and 1 or pixelCount, nL and -1 or 1 do
            buffer[ i ] = buffer[ i + offset ] or blank
        end
    end

    function redirect.isColour()
        return isColour
    end

    -- American spelling compatibility layer
    redirect.isColor = redirect.isColour
	redirect.setBackgroundColor = redirect.setBackgroundColour
	redirect.setTextColor = redirect.setTextColour
	redirect.getBackgroundColor = redirect.getBackgroundColour
	redirect.getTextColor = redirect.getTextColour

    return redirect
end
