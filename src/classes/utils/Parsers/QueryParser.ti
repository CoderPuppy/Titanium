local function parseValue( val )
    if val == "true" then return true
    elseif val == "false" then return false end

    return tonumber( val ) or error("Invalid value passed for parsing '"..tostring( val ).."'")
end

class QueryParser extends Parser

function QueryParser:__init__( queryString )
    self:super( QueryLexer( queryString ).tokens )
end

function QueryParser:parse()
    local allQueries, currentQuery = {}, {}

    local token = self:stepForward()
    while token do
        if token.type == "QUERY_TYPE" then
            if currentQuery.type then
                self:throw("Duplicate query 'type'. Tried to set type '"..token.value.."' when already set to '"..currentQuery.type.."'")
            end

            currentQuery.type = token.value
        elseif token.type == "QUERY_ID" then
            if currentQuery.id then
                self:throw("Duplicate query 'id'. Tried to set type '"..token.value.."' when already set to '"..currentQuery.type.."'")
            end

            currentQuery.id = token.value
        elseif token.type == "QUERY_CLASS" then
            if not currentQuery.classes then
                currentQuery.classes = {}
            end

            table.insert( currentQuery.classes, token.value )
        elseif token.type == "QUERY_SEPERATOR" then
            if next( currentQuery ) then
                allQueries[ #allQueries + 1 ] = currentQuery
                currentQuery = {}
            else
                self:throw "Tried to seperate query, no query (empty) found on left of seperator."
            end
        elseif token.type == "QUERY_COND_OPEN" then
            currentQuery.condition = self:parseCondition()
        else
            self:throw("Unexpected '"..token.type.."'")
        end

        token = self:stepForward()
    end

    if next( currentQuery ) then
        allQueries[ #allQueries + 1 ] = currentQuery
    end

    self.query = allQueries
end

function QueryParser:parseCondition()
    local conditions, condition = {}, {}

    local token = self:stepForward()
    while true do
        if token.type == "QUERY_COND_ENTITY" and ( condition.symbol or not condition.property ) then
            condition[ condition.symbol and "value" or "property" ] = condition.symbol and parseValue( token.value ) or token.value
        elseif token.type == "QUERY_COND_STRING_ENTITY" and condition.symbol then
            condition.value = token.value
        elseif token.type == "QUERY_COND_SYMBOL" and not condition.property and token.value == "#" then
            condition.modifier = token.value
        elseif token.type == "QUERY_COND_SYMBOL" and ( condition.property ) then
            condition.symbol = token.value
        elseif token.type == "QUERY_COND_SEPERATOR" and next( condition ) then
            conditions[ #conditions + 1 ] = condition
            condition = {}
        elseif token.type == "QUERY_COND_CLOSE" and ( not condition.property or ( condition.property and condition.value ) ) then
            break
        else
            self:throw( "Unexpected '"..token.type.."' inside of condition block" )
        end

        token = self:stepForward()
    end

    if next( condition ) then
        conditions[ #conditions + 1 ] = condition
    end

    return #conditions > 0 and conditions or nil
end
